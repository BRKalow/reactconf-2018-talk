import { Appear, Image } from 'mdx-deck';
import { Split } from 'mdx-deck/layouts';
import { CodeSurfer } from 'mdx-deck-code-surfer';
import nightOwl from 'prism-react-renderer/themes/nightOwl';
import QuoteLayout from './src/quote-layout'
import Layout from './src/layout';
import LayoutNoFooter from './src/layout-no-footer';
import LayoutCenter from './src/layout-center';
import UnitOfWork from './src/unit-of-work';
import { ImpressionsManager, IncrementImpressions, ImpressionsCounter } from './src/impression-tracker.js';

export { default as theme } from './src/theme'

export default LayoutNoFooter

## Components as
# Units of Work

---

export default LayoutNoFooter

# Hi, I'm Bryce! ðŸ‘‹

Engineer at Target

@brkalow

---

export default QuoteLayout

> Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.

â€” [reactjs.org](https://reactjs.org/docs/components-and-props.html)

---

export default Layout

## Components also tend to have a lot of other responsibilities...

<ul>
  <Appear>
    <li>Fetch data</li>
    <li>Add event listeners</li>
    <li>Handle navigation</li>
    <li>Manage state</li>
    <li>Transform data</li>
    <li>Set timers</li>
    <li>Control focus</li>
    <li>Track user interactions</li>
    <li>Inject scripts</li>
    <li>Handle scrolling</li>
  </Appear>
</ul>

---

![](assets/this-is-fine.jpg)

---

export default Layout

## We use the React lifecycle to control the execution flow of our applications in between renders

---

export default Layout

## How can we orchestrate functionality within the React lifecycle without constructing brittle, hard-to-maintain logic? ðŸ¤”

```notes

```

---

export default LayoutCenter

# With components!

![](assets/fallon-nice.gif)

---

export default Layout

## Components don't have to _render_ anything
but they can still _do_ something


```notes
Returning null from render is totally valid, you might even be using this pattern already without realizing it.
```

---

export default Layout

### With renderless components, we can continue working within the React lifecycle to control our application, with all the benefits of representing UI as components!

```notes
This is crucial for large React applications, as most things are dictated by and revolve around
the React component tree. Navigation, app state, and configuration are often all orchestrated by
some piece of React.
```

---

export default LayoutNoFooter

<CodeSurfer
  title="<ClientVersionCheck>"
  code={require("!raw-loader!./src/client-version-check.js")}
  theme={nightOwl}
  lang="javascript"
  showNumbers={false}
  dark={false}
  steps={[
    { lines: [7,8,9] },
    { lines: [23,24] },
    { lines: [28] }
  ]}
/>

---

export default LayoutCenter

# In the wild

---

export default Layout

# react-router `<Redirect>`

```js
import { Route, Redirect } from 'react-router'

<Route exact path="/" render={() => (
  loggedIn ? (
    <Redirect to="/dashboard"/>
  ) : (
    <PublicHomePage/>
  )
)}/>
```

```notes
`react-router` uses this pattern quite a bit, they have a renderless component in their source called `<Lifecycle>`.
From: https://reacttraining.com/react-router/web/api/Redirect
```

---

export default Layout

# Embrace using components beyond presentation
Think in React

---

export default Layout

# Thanks!

Slides: \<link to slides\>
